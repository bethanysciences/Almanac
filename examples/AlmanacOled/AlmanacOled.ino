 /*
 * -----------------------------------------------------------------------------
 * 
 * Almanac for specific Latitude and Longitudes
 * Operates independantly not needing an Internet connection
 * 
 * Bob Smith https://github.com/bethanysciences/almanac
 *  
 * Written and compiled under version 1.8.12+ of the Arduino IDE using the 
 * AVRISP mkII programmer for Arduino for Nano 33 IoT and Arduino Nano 33 
 * BLE based microprocessors
 * 
 * This program distributed WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  
 * Predictions generated by this program should NOT be used for navigation.
 * No accuracy or warranty is given or implied for these predictions.
 * 
 * 
 * HARDWARE USED
 * -----------------------------------------------------------------------------
 * 
 * Microprocessors written for (others may work)
 * Arduino Nano 33 IoT https://store.arduino.cc/usa/nano-33-iot and 
 * Arduino Nano 33 BLE Sense https://store.arduino.cc/usa/nano-33-ble-sense
 * Arduino Nano 33 BLE https://store.arduino.cc/usa/nano-33-ble
 * 
 * 
 * Time Maintenance
 * Adafruit's battery backed I2C Maxim DS3231 Real Time Clock (RTC) Module 
 * https://www.adafruit.com/product/3013 using Adafruit's 
 * library https://github.com/adafruit/RTClib a fork of JeeLab's library 
 * https://git.jeelabs.org/jcw/rtclib - installed from Arduino IDE as [RTClib]
 * 
 * 
 * Lightening Events
 * Sparkfun's Franklin AS3935 Lightning Detector Breakout Board V2
 * https://www.sparkfun.com/products/15441 using Sparkfun's library 
 * https://github.com/sparkfun/SparkFun_AS3935_Lightning_Detector_Arduino_Library
 *  - installed from Arduino IDE as [SparkFun AS3935]
 * 
 * distanceToStorm()           strike distance in kilometers x .621371 for miles
 * clearStatistics()           zero distance registers
 * resetSettings()             resets to defaults
 * setNoiseLevel(int)          read/set noise floor 1-7 (2 default)
 * readNoiseLevel()
 * maskDisturber(bool)         read/set mask disturber events (false default)
 * readMaskDisturber(bool)
 * setIndoorOutdoor(hex)       0xE, 0x12 (default) attunates for inside use
 * readIndoorOutdoor(hex)
 * watchdogThreshold(int)      read/set watchdog threshold 1-10 (2 default)
 * readWatchdogThreshold()
 * spikeRejection(int)         read/set spike reject 1-11 (2 default)
 * readSpikeRejection()
 * lightningThreshold(int)     read/set # strikes to trip interrupt 1,5,9, or 26
 * readLightningThreshold()
 * lightningEnergy(long)       strike energy
 * lightning.powerDown()       wake after power down resets internal resonators
 * lightning.wakeUp()          to default antenna resonance frequency (500kHz)
 *                             skewing built-up calibrations. Calibrate 
 *                             antenna before using this function
 * 
 * 
 * Display
 * MakerHawk's 1.5" 128x128 SSD1327 I2C Driven OLED display from Amazon 
 * https://www.amazon.com/s?k=MakerHawk&ref=bl_dp_s_web_18510440011
 * driven by olikraus's U8g2: Library for monochrome displays, ver 2 
 * https://github.com/olikraus/u8g2 - install from Arduino IDE as [U8g2] fonts
 * can be found here https://github.com/olikraus/u8g2/wiki/fntlist8x8
 * 
 * 
 * ADDITIONAL FUNCTIONS USED
 * -----------------------------------------------------------------------------
 * Tide events calculated using Luke Miller's library of NOAA harmonic data 
 * https://github.com/millerlp/Tide_calculator derived from David Flater's
 * XTide application https://flaterco.com/xtide/xtide.html. Futher logic is
 * derived from rabbitcreek's https://github.com/rabbitcreek/tinytideclock
 * 
 * Sun events calculated using SunEvents library 
 * https://github.com/bethanysciences/SunEvents outputting sunrises and sets
 * to a RTClib DateTime object, a derivative of DM Kishi's library 
 * https://github.com/dmkishi/Dusk2Dawn, based on a port of NOAA's Solar 
 * Calculator https://www.esrl.noaa.gov/gmd/grad/solcalc/
 *  
 * 
 * This application and project are open source using MIT License see 
 * license.txt.
 *  
 * See included library github directories for their respecive licenses
 *  
 *******************|*******************|*******************|******************/


// ------------  AS3935 LIGHTNING  ------------ //

#include <SparkFun_AS3935.h>
#define LIGHTNING_INT           0x08
#define DISTURBER_INT           0x04
#define NOISE_INT               0x01
#define AS3935_CS               11     // AS3935 chip select pin
#define AS3935_STRIKE           4      // strike detection interrupt pin (HIGH)
byte noiseFloor = 2;
byte watchDogVal = 2;
byte spike = 2;
byte lightningThresh = 1;
SparkFun_AS3935 strike;


// ------------  NEO PIXELS  ------------ //
#include <Adafruit_NeoPixel_ZeroDMA.h>
#define NEO_PIN         8
#define NEO_PIXELS      1
Adafruit_NeoPixel_ZeroDMA strip(NEO_PIXELS, NEO_PIN, NEO_GRB);


// ------------  OLED DISPLAYS  ------------ //
#include <U8x8lib.h>                        // version=2.27.6
U8X8_SSD1327_MIDAS_128X128_HW_I2C u8x8(U8X8_PIN_NONE);
#define SPRITE_X            0               // visual indicator screen positions
#define SPRITE_Y            14


// ------------  DS3231 REAL-TIME CLOCK  ------------ //
#include <RTClib.h>                         // version=1.8.0
RTC_DS3231 rtc;                             // instantiate RTC module
#define USE_USLDT           true            // location uses US daylight savings
char LOC[3][4]              = {"LST",       // for Local Standard Time (LST)
                               "LDT"};      // and Local Daylight Time (LDT)
#define GMT_OFFSET          -5              // LST hours GMT offset


// ------------  SUN EVENTS  ------------ //
#include <SunEvent.h>                       // version=0.1.0
float LATITUDE              = 27.9719;      // Clearwater Beach, FL, USA
float LONGITUDE             = -82.8265;
SunEvent ClearwaterBeach(LATITUDE, LONGITUDE, GMT_OFFSET);


// ------------  TIDE CALCULATIONS  ------------ //
#include "TidelibClearwaterBeachGulfOfMexicoFlorida.h"
TideCalc myTideCalc;
float INTERVAL              = 1 * 5 * 60L;  // tide calc interval
float results;                              // needed to print tide height



// ------------  SETUP RUNS ONCE  ------------ // 
void setup() {
    asm(".global _printf_float");           // printf renders floats

    Serial.begin(115200);                                       // while(!Serial);
    Serial.println("\n\nstartup");


    pinMode(AS3935_STRIKE, INPUT);                              // strike detected int pin set
    SPI.begin();
    while(!strike.beginSPI(AS3935_CS, 2000000));
    // strike.maskDisturber(true);                                 // default = false


    u8x8.begin();                           // Start OLED display
    u8x8.setFont(u8x8_font_pressstart2p_f); // load font
    
    if (! rtc.begin()) while (1);           // wait until RTC starts
    if (rtc.lostPower()) {                  // if module lost power reset time
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }

    delay(5000);                            // flush registers
    
    u8x8.drawString(4, 0,  "ALMANAC");      // push static labels
    u8x8.drawString(2, 4,  "Tide Events");
    u8x8.drawString(0, 5,  "H");
    u8x8.drawString(1, 6,  "Current");    
    u8x8.drawString(0, 7,  "L");
    u8x8.drawString(2, 9,  "Sun Events");
    u8x8.drawString(0, 10, "Rise");
    u8x8.drawString(0, 11, "Daylight");
    u8x8.drawString(0, 12, "Set");
}

// ------------  MAIN  ------------ // 
void loop() {

    if(digitalRead(AS3935_STRIKE) == HIGH) {    // check for lightening event
        eventDetected();
    }

    displayTime();                              // get current & update time
  
    getTideEvents();                            // run tide and sun events
    getSunEvents();

    delayLoop();                                // loop delay
}


// ------------  GET CURRENT TIME AND UPDATE DISPLAY ------------ // 
void displayTime() {
    DateTime now = rtc.now();                   // get current time from RTC
    char curr_date_buf[] = "DDD  MM/DD/YY";
    u8x8.drawString(1, 1, now.toString(curr_date_buf));
    char curr_time_buf[] = "hh:mm ap";
    u8x8.drawString(1, 2, now.toString(curr_time_buf));
    u8x8.drawString(26, 2, LOC[isLDT(now)]);    // render LST ot LDT
}


// ------------  DELAY LOOP ------------ // 
void delayLoop() {
    u8x8.drawString(SPRITE_X, SPRITE_Y, "|");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "/");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "-");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "\\");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "|");
}


// ------------  AS3935 INTERRUPT TRIPPED ------------ // 
void eventDetected() {
    Serial.print("event register 0x0");
    
    int intVal = strike.readInterruptReg();
    Serial.print(intVal, HEX);
    
    if(intVal == NOISE_INT) {
        Serial.println("\tnoise event");
        strip.setPixelColor(0, 255, 255, 0);
    }
    else if(intVal == DISTURBER_INT) {
        Serial.println("\tdisturber event");
        strip.setPixelColor(0, 255, 0, 255);
    }
    else if(intVal == LIGHTNING_INT) {
        Serial.print("\tstrike distance ");           
        Serial.print(strike.distanceToStorm() /.621371);         //  * .621371 for miles
        Serial.println(" mi."); 
        strip.setPixelColor(0, 0, 0, 255);
    }
    strip.show();
}


// ------------  CALC AND DISPLAY TIDE EVENTS  ------------ // 
void getTideEvents() {
    u8x8.drawString(SPRITE_X, SPRITE_Y, "T");   // render activity sprite
    DateTime futureHigh;
    DateTime futureLow;
    DateTime future;
    uint8_t slope;
    uint8_t i               = 0;
    uint8_t zag             = 0;
    bool    gate            = 1;
    float   tidalDifference = 0;
    bool    bing            = 1;
    bool    futureLowGate   = 0;
    bool    futureHighGate  = 0;
    
    DateTime now = rtc.now();                   // current time from RTC
    DateTime adjnow(now.unixtime() 
             - (isLDT(now) * 3600));            // convert to LST during LDT

    float pastResult = myTideCalc.currentTide(adjnow);

    u8x8.setCursor(9, 6);
    u8x8.print(pastResult, 2);
    u8x8.print("'");
        
    while(bing){
        i++;
        DateTime future(adjnow.unixtime() + (i * INTERVAL));
        results = myTideCalc.currentTide(future);
        tidalDifference = results - pastResult;
        if (gate){
            if(tidalDifference < 0) slope = 0;
            else slope = 1;
            gate = 0;
        }
        if(tidalDifference > 0 && slope == 0) {
            futureLow = future;
            gate = 1;
            //bing = 0;
            futureLowGate = 1;
        }
        else if(tidalDifference < 0 && slope == 1){
            futureHigh = future;
            gate = 1;
            //bing = 0;
            futureHighGate = 1;
        }
        if(futureHighGate && futureLowGate) {
            bool hiLow;
            float resultsHigh = myTideCalc.currentTide(futureHigh);
            float resultsLow  = myTideCalc.currentTide(futureLow);
        
            if(int(futureHigh.unixtime() - futureLow.unixtime()) < 0) hiLow = 1;
            if(int(futureHigh.unixtime() - futureLow.unixtime()) > 0) hiLow = 0;
            
            if (hiLow) {
                DateTime adjHigh(futureHigh.unixtime() + 
                (isLDT(futureHigh) * 3600));

                char high_buf[] = "hh:mm ap";
                u8x8.drawString(2, 5, adjHigh.toString(high_buf));
                u8x8.setCursor(27, 5);
                u8x8.print(resultsHigh, 1);
                u8x8.print("'");
                
                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));
                
                char low_buf[] = "hh:mm ap";
                u8x8.drawString(2, 7, adjLow.toString(low_buf));
                u8x8.setCursor(27, 7);
                u8x8.print(resultsLow, 1);
                u8x8.print("'");
            }
            else {
                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));
                
                char low_buf[] = "hh:mm ap";
                u8x8.drawString(2, 7, adjLow.toString(low_buf));
                u8x8.setCursor(27, 7);
                u8x8.print(resultsLow, 1);
                u8x8.print("'");
                
                DateTime adjHigh(futureHigh.unixtime() + 
                         (isLDT(futureHigh) * 3600)); 
                char high_buf[] = "hh:mm ap";
                u8x8.drawString(2, 5, adjHigh.toString(high_buf));
                u8x8.setCursor(27, 5);
                u8x8.print(resultsHigh, 1);
                u8x8.print("'");
            }
            results = myTideCalc.currentTide(adjnow);
            gate = 1;
            bing = 0;
            futureHighGate = 0;
            futureLowGate  = 0;
        }
        pastResult = results;
    }
}


// ------------  CALC AND DISPLAY SUN EVENTS  ------------ //
void getSunEvents() {
    u8x8.drawString(SPRITE_X, SPRITE_Y, "S");               // activity sprite
    DateTime nextrise = ClearwaterBeach.sunrise(rtc.now());    
    char rise_buf[] = "hh:mm ap";
    u8x8.drawString(5, 10, nextrise.toString(rise_buf));

    DateTime nextset  = ClearwaterBeach.sunset(rtc.now());    
    char set_buf[] = "hh:mm ap";
    u8x8.drawString(5, 12, nextset.toString(set_buf));

    TimeSpan sunlight =  nextset.unixtime() - nextrise.unixtime();
    //uint8_t D = (nextset.unixtime() - nextrise.unixtime());
    char light_buf[20];
    sprintf(light_buf, "%d:%d", sunlight.hours(), sunlight.minutes());
    u8x8.drawString(10, 11, light_buf);
}


// ------------  DETERMINE IF US DAYLIGHT SAVINGS TIME  ------------ //
bool isLDT(const DateTime& curLST) {
    if(!USE_USLDT) return false;            // location uses US daylight savings
    int y = curLST.year() - 2000;
    int x = (y + y/4 + 2) % 7;              // set boundary Sundays

    if(curLST.month() == 3 && 
       curLST.day() == (14 - x) && 
       curLST.hour() >= 2)
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 3 && 
       curLST.day() > (14 - x) || 
       curLST.month() > 3) 
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 11 && 
       curLST.day() == (7 - x) && 
       curLST.hour() >= 2) 
       return false;                        // time is Local Standard Time (LST)

    if(curLST.month() == 11 &&
       curLST.day() > (7 - x) || 
       curLST.month() > 11 || 
       curLST.month() < 3) 
       return false;                        // time is Local Standard Time (LST)
}


// ------------  RUN NEOPIXELS  ------------ //
void cycleNEO() {
    Serial.print("cycleNEO\t");

    // --- Cycle NEO Pixel ---
    strip.begin();
    strip.setBrightness(32);
    strip.setPixelColor(0, 255, 0, 0); strip.show(); delay(100);
    Serial.print("red ");
    strip.setPixelColor(0, 0, 255, 0); strip.show(); delay(100);
    Serial.print("green ");
    strip.setPixelColor(0, 0, 0, 255); strip.show(); delay(100);
    Serial.print("blue ");
    strip.setPixelColor(0, 255, 255, 255); strip.show();
    Serial.println("white ");
}


// ------------  DISPLAY AS3935 PARAMETERS  ------------ //
void statusScreen() {
    Serial.print("statusScreen\t");
    
    // --- Get AS3935 Paramters ---
    char disturberMask[2][20]   = {"ON", "OFF"};
    char inOutdoor[2][20]       = {"IN", "OUT"};
    int inOut;
    char buf01[40];

    if (strike.readIndoorOutdoor() == 18) inOut = 0;
    else inOut = 1;

    sprintf(buf01, "dist %s  %s  noise %d  watch %d  reg %d  strks %d", 
            disturberMask[strike.readMaskDisturber()], inOutdoor[inOut], 
            strike.readNoiseLevel(), strike.readWatchdogThreshold(),
            strike.readSpikeRejection(), strike.readLightningThreshold());

    
    // --- Display Status ---
    // display.setFont(&FreeSans9pt7b);
    display.setFont();
    display.setTextColor(GxEPD_BLACK);
    display.setRotation(1);
    
    display.setPartialWindow(0, 110, 296, 17);
    display.firstPage();
    do {
        display.drawRoundRect(1, 110, 294, 17, 4, GxEPD_BLACK);
        display.setCursor(8, 116);
        display.print(buf01);
        display.drawFastVLine(60, 110, 17, GxEPD_BLACK);
        display.drawFastVLine(85, 110, 17, GxEPD_BLACK);
        display.drawFastVLine(140, 110, 17, GxEPD_BLACK);
        display.drawFastVLine(195, 110, 17, GxEPD_BLACK);    
        display.drawFastVLine(235, 110, 17, GxEPD_BLACK);    
    }
    while (display.nextPage());
    Serial.println(buf01);
}


// ------------  DISPLAY BATTERY SPRITE  ------------ //
void batterySprite() {
    Serial.print("batterySprite\t");

    #define VBATPIN         A6
    
    float batteryVolts = analogRead(VBATPIN);
    batteryVolts *= 2;
    batteryVolts *= 3.3;
    batteryVolts /= 1024;

    #define BATTTEXT_STARTX     200                 //  Battery Text X Position
    #define BATTTEXT_STARTY     1                   //  Battery Text Y Position
    #define BATTICON_STARTX     265                 //  Battery Icon X Position
    #define BATTICON_STARTY     1                   //  Battery Icon X Position
    #define BATTICON_WIDTH      30                  //  Battery Icon Width
    #define BATTICON_BARWIDTH3  ((BATTICON_WIDTH - 6) / 3)  //  Bar Width

    char buf0[15];
    sprintf(buf0, "batt %d.%02dv", (int)batteryVolts, 
                                   (int)(batteryVolts*100)%100);

    display.setFont();
    display.setTextColor(GxEPD_BLACK);
    display.setRotation(1);

    display.setPartialWindow(/*x start*/ 200, /*y start*/ 0, 
                             /*width*/ 96, /*height*/ 16);
    display.firstPage();
    
    do {    
        display.setCursor(BATTTEXT_STARTX, BATTTEXT_STARTY);
        display.print(buf0);

        display.drawLine( BATTICON_STARTX + 1, BATTICON_STARTY,     
                          BATTICON_STARTX +    BATTICON_WIDTH - 4,  
                          BATTICON_STARTY,     GxEPD_BLACK);
        display.drawLine( BATTICON_STARTX,     BATTICON_STARTY + 1, 
                          BATTICON_STARTX,     BATTICON_STARTY + 5,
                          GxEPD_BLACK);
        display.drawLine( BATTICON_STARTX + 1, BATTICON_STARTY + 6, 
                          BATTICON_STARTX +    BATTICON_WIDTH - 4,  
                          BATTICON_STARTY + 6, GxEPD_BLACK);
        display.drawPixel(BATTICON_STARTX +    BATTICON_WIDTH - 3, 
                          BATTICON_STARTY + 1, GxEPD_BLACK);
        display.drawPixel(BATTICON_STARTX +    BATTICON_WIDTH - 2,  
                          BATTICON_STARTY + 1, GxEPD_BLACK);
        display.drawLine( BATTICON_STARTX +    BATTICON_WIDTH - 1,  
                          BATTICON_STARTY + 2, BATTICON_STARTX +    
                          BATTICON_WIDTH - 1,  BATTICON_STARTY + 4, 
                          GxEPD_BLACK);
        display.drawPixel(BATTICON_STARTX +    BATTICON_WIDTH - 2, 
                          BATTICON_STARTY + 5, GxEPD_BLACK);
        display.drawPixel(BATTICON_STARTX +    BATTICON_WIDTH - 3, 
                          BATTICON_STARTY + 5, GxEPD_BLACK);
        display.drawPixel(BATTICON_STARTX +    BATTICON_WIDTH - 3, 
                          BATTICON_STARTY + 6, GxEPD_BLACK);
    
        if (batteryVolts > 4.26F) 
            display.fillRect(BATTICON_STARTX + 2, BATTICON_STARTY + 2, 
                             BATTICON_BARWIDTH3 * 3, 3, GxEPD_WHITE);
        else if ((batteryVolts <= 4.26F) && (batteryVolts >= 4.1F)) {
            for (uint8_t i = 0; i < 3; i++) {
                display.fillRect(BATTICON_STARTX + 2 + 
                                (i * BATTICON_BARWIDTH3), 
                                BATTICON_STARTY + 2, BATTICON_BARWIDTH3 - 1, 
                                3, GxEPD_BLACK);
            }
        }
        else if ((batteryVolts < 4.1F) && (batteryVolts >= 3.8F)) {
            for (uint8_t i = 0; i < 2; i++) {
                display.fillRect(BATTICON_STARTX + 2 + 
                (i * BATTICON_BARWIDTH3), BATTICON_STARTY + 2, 
                BATTICON_BARWIDTH3 - 1, 3, GxEPD_RED);
            }
        }
        else if ((batteryVolts < 3.8F) && (batteryVolts >= 3.4F)) {
            display.fillRect(BATTICON_STARTX + 2, BATTICON_STARTY + 2, 
                             BATTICON_BARWIDTH3 - 1, 3, GxEPD_RED);
        }
    }
    while (display.nextPage());
    Serial.println(buf0);
}


// ------------  STARTUP MELODY  ------------ //
void startupMelody() {
    Serial.print("startupMelody\t");
    
    int melody[]        = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, 
                            NOTE_G3, 0,       NOTE_B3, NOTE_C4 };

    int noteDurations[] = { 4, 8, 8, 4, 4, 4, 4, 4 };    // 1/4 & 1/8th notes
    for (int thisNote = 0; thisNote < 8; thisNote++) {
        int noteDuration = 1000 / noteDurations[thisNote];
        tone(TONE_PIN, melody[thisNote], noteDuration);
        int pauseBetweenNotes = noteDuration * 1.30;
        delay(pauseBetweenNotes);
        Serial.print(thisNote);
        noTone(TONE_PIN);
    }
    Serial.println("done");
}


// ------------  STARTUP MELODY  ------------ //
void introScreen() {
    Serial.println("introScreen()");

    display.setFont(&FreeSans12pt7b);
    display.setRotation(1);
    display.fillScreen(GxEPD_WHITE);
    display.setTextColor(GxEPD_RED);
    int16_t tbx, tby; uint16_t tbw, tbh;
    const char Start[] = "Strike Detector";
    display.getTextBounds(Start, 0, 0, &tbx, &tby, &tbw, &tbh);
    uint16_t x = ((display.width() - tbw) / 2) - tbx;
    uint16_t y = ((display.height() - tbh) / 2) - tby;
    display.setFullWindow();
    display.firstPage();
    do {
        display.setCursor(x, y);
        display.print(Start);
    }
    while (display.nextPage());
}