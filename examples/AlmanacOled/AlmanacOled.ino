 /*******************|*******************|*******************|*******************
 *  Almanac for specific Latitude and Longitudes
 *  Operates independantly not needing an Internet connection
 *  
 *  Bob Smith https://github.com/bethanysciences/almanac
 *  
 *  Written under version 1.8.12 of the Arduino IDE
 *  for Arduino Nano 33 IoT and Arduino Nano 33 BLE microprocessors
 *  
 *  This program distributed WITHOUT ANY WARRANTY; without even the implied 
 *  warranty of MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  
 *  Predictions generated by this program should NOT be used for navigation.
 *  No accuracy or warranty is given or implied for these predictions.
 *  
 *  Time grabbed from Adafruit's battery backed I2C Maxim DS3231 Real Time 
 *  Clock (RTC) module (https://www.adafruit.com/product/3013) using Adafruit's 
 *  library (https://github.com/adafruit/RTClib) a fork of JeeLab's library 
 *  (https://git.jeelabs.org/jcw/rtclib). - install from Arduino IDE as [RTClib]
 *   
 *  Tide events calculated using Luke Miller's library of NOAA harmonic data 
 *  https://github.com/millerlp/Tide_calculator derived from David Flater's
 *  XTide application https://flaterco.com/xtide/xtide.html. Futher logic is
 *  derived from rabbitcreek's https://github.com/rabbitcreek/tinytideclock
 *  
 *  Sun events calculated using SunEvents library 
 *  https://github.com/bethanysciences/SunEvents outputting sunrises and sets
 *  to a RTClib DateTime object, a aerivative of DM Kishi's library 
 *  https://github.com/dmkishi/Dusk2Dawn, based on a port of NOAA's Solar 
 *  Calculator https://www.esrl.noaa.gov/gmd/grad/solcalc/
 *  
 *  Output to MakerHawk's 1.5" 128x128 SSD1327 I2C Driven OLED display from
 *  Amazon driven by olikraus's U8g2: Library for monochrome displays, ver 2 
 *  https://github.com/olikraus/u8g2 - install from Arduino IDE as [U8g2] fonts
 *  can be found here https://github.com/olikraus/u8g2/wiki/fntlist8x8
 *  
 *  This application and project are open source using MIT License see 
 *  license.txt.
 *  
 *  See included library github directories for their respecive licenses
 *  
 *******************|*******************|*******************|******************/


#include <RTClib.h>                         // version=1.8.0
#include <SunEvent.h>                       // version=0.1.0
#include <U8x8lib.h>                        // version=2.27.6
#include "TidelibClearwaterBeachGulfOfMexicoFlorida.h"


/*******************|*******************|*******************|*******************
 *                 LOAD GLOBAL HARDWARE VARIABLES & FUNCTIONS
 *******************|*******************|*******************|******************/

U8X8_SSD1327_MIDAS_128X128_HW_I2C u8x8(U8X8_PIN_NONE);
#define SPRITE_X            0               // visual indicator screen positions
#define SPRITE_Y            14

RTC_DS3231 rtc;                             // instantiate RTC module
#define USE_USLDT           true            // location uses US daylight savings
char LOC[3][4]              = {"LST",       // for Local Standard Time (LST)
                               "LDT"};      // and Local Daylight Time (LDT)
#define GMT_OFFSET          -5              // LST hours GMT offset

/*******************|*******************|*******************|*******************
 *                  LOAD GLOBAL LOCATION VARIABLES & FUNCTIONS
 *******************|*******************|*******************|******************/

float LATITUDE              = 27.9719;
float LONGITUDE             = -82.8265;
SunEvent ClearwaterBeach(LATITUDE, LONGITUDE, GMT_OFFSET);

TideCalc myTideCalc;
float INTERVAL              = 1 * 5 * 60L;  // tide calc interval
float results;                              // needed to print tide height


/*******************|*******************|*******************|*******************
 *                                    SETUP 
 *******************|*******************|*******************|******************/

void setup() {
    asm(".global _printf_float");           // printf renders floats

    u8x8.begin();                           // Start OLED display
    u8x8.setFont(u8x8_font_pressstart2p_f); // load font
    
    if (! rtc.begin()) while (1);           // wait until RTC starts
    if (rtc.lostPower()) {                  // if module lost power reset time
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }

    delay(5000);                            // flush registers
    
    u8x8.drawString(4, 0,  "ALMANAC");      // push static labels
    u8x8.drawString(2, 4,  "Tide Events");
    u8x8.drawString(0, 5,  "H");
    u8x8.drawString(1, 6,  "Current");    
    u8x8.drawString(0, 7,  "L");
    u8x8.drawString(2, 9,  "Sun Events");
    u8x8.drawString(0, 10, "Rise");
    u8x8.drawString(0, 11, "Daylight");
    u8x8.drawString(0, 12, "Set");
}

void loop() {

    /******************|*******************|*******************|****************
    *                     GET CURRENT TIME AND UPDATE DISPLAY
    *******************|*******************|*******************|***************/
    
    DateTime now = rtc.now();                   // get current time from RTC
    char curr_date_buf[] = "DDD  MM/DD/YY";
    u8x8.drawString(1, 1, now.toString(curr_date_buf));
    char curr_time_buf[] = "hh:mm ap";
    u8x8.drawString(1, 2, now.toString(curr_time_buf));
    u8x8.drawString(26, 2, LOC[isLDT(now)]);    // render LST ot LDT


    /******************|*******************|*******************|****************
    *                         RUN SUN AND TIDE EVENTS 
    *******************|*******************|*******************|***************/
    
    getTidesEvents();
    getSunEvents();


    /******************|*******************|*******************|****************
    *            LOOP DELAY AND RENDER SPRITE TO INDICATE ACTIVITY 
    *******************|*******************|*******************|***************/

    u8x8.drawString(SPRITE_X, SPRITE_Y, "|");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "/");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "-");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "\\");
    delay(250);
    u8x8.drawString(SPRITE_X, SPRITE_Y, "|");
}


/*******************|*******************|*******************|*******************
 *                         CALC AND DISPLAY TIDE EVENTS
 *******************|*******************|*******************|******************/
 
void getTidesEvents() {
    u8x8.drawString(SPRITE_X, SPRITE_Y, "T");   // render activity sprite
    DateTime futureHigh;
    DateTime futureLow;
    DateTime future;
    uint8_t slope;
    uint8_t i               = 0;
    uint8_t zag             = 0;
    bool    gate            = 1;
    float   tidalDifference = 0;
    bool    bing            = 1;
    bool    futureLowGate   = 0;
    bool    futureHighGate  = 0;
    
    DateTime now = rtc.now();                   // current time from RTC
    DateTime adjnow(now.unixtime() 
             - (isLDT(now) * 3600));            // convert to LST during LDT

    float pastResult = myTideCalc.currentTide(adjnow);

    u8x8.setCursor(9, 6);
    u8x8.print(pastResult, 2);
    u8x8.print("'");
        
    while(bing){
        i++;
        DateTime future(adjnow.unixtime() + (i * INTERVAL));
        results = myTideCalc.currentTide(future);
        tidalDifference = results - pastResult;
        if (gate){
            if(tidalDifference < 0) slope = 0;
            else slope = 1;
            gate = 0;
        }
        if(tidalDifference > 0 && slope == 0) {
            futureLow = future;
            gate = 1;
            //bing = 0;
            futureLowGate = 1;
        }
        else if(tidalDifference < 0 && slope == 1){
            futureHigh = future;
            gate = 1;
            //bing = 0;
            futureHighGate = 1;
        }
        if(futureHighGate && futureLowGate) {
            bool hiLow;
            float resultsHigh = myTideCalc.currentTide(futureHigh);
            float resultsLow  = myTideCalc.currentTide(futureLow);
        
            if(int(futureHigh.unixtime() - futureLow.unixtime()) < 0) hiLow = 1;
            if(int(futureHigh.unixtime() - futureLow.unixtime()) > 0) hiLow = 0;
            
            if (hiLow) {
                DateTime adjHigh(futureHigh.unixtime() + 
                (isLDT(futureHigh) * 3600));

                char high_buf[] = "hh:mm ap";
                u8x8.drawString(2, 5, adjHigh.toString(high_buf));
                u8x8.setCursor(27, 5);
                u8x8.print(resultsHigh, 1);
                u8x8.print("'");
                
                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));
                
                char low_buf[] = "hh:mm ap";
                u8x8.drawString(2, 7, adjLow.toString(low_buf));
                u8x8.setCursor(27, 7);
                u8x8.print(resultsLow, 1);
                u8x8.print("'");
            }
            else {
                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));
                
                char low_buf[] = "hh:mm ap";
                u8x8.drawString(2, 7, adjLow.toString(low_buf));
                u8x8.setCursor(27, 7);
                u8x8.print(resultsLow, 1);
                u8x8.print("'");
                
                DateTime adjHigh(futureHigh.unixtime() + 
                         (isLDT(futureHigh) * 3600)); 
                char high_buf[] = "hh:mm ap";
                u8x8.drawString(2, 5, adjHigh.toString(high_buf));
                u8x8.setCursor(27, 5);
                u8x8.print(resultsHigh, 1);
                u8x8.print("'");
            }
            results = myTideCalc.currentTide(adjnow);
            gate = 1;
            bing = 0;
            futureHighGate = 0;
            futureLowGate  = 0;
        }
        pastResult = results;
    }
}


/*******************|*******************|*******************|*******************
 *                         CALC AND DISPLAY SUN EVENTS
 *******************|*******************|*******************|******************/
 
void getSunEvents() {
    u8x8.drawString(SPRITE_X, SPRITE_Y, "S");               // activity sprite
    DateTime nextrise = ClearwaterBeach.sunrise(rtc.now());    
    char rise_buf[] = "hh:mm ap";
    u8x8.drawString(5, 10, nextrise.toString(rise_buf));

    DateTime nextset  = ClearwaterBeach.sunset(rtc.now());    
    char set_buf[] = "hh:mm ap";
    u8x8.drawString(5, 12, nextset.toString(set_buf));

    TimeSpan sunlight =  nextset.unixtime() - nextrise.unixtime();
    //uint8_t D = (nextset.unixtime() - nextrise.unixtime());
    char light_buf[20];
    sprintf(light_buf, "%d:%d", sunlight.hours(), sunlight.minutes());
    u8x8.drawString(10, 11, light_buf);
}


/*******************|*******************|*******************|*******************
 *                    DETERMINE IF US DAYLIGHT SAVINGS TIME
 *******************|*******************|*******************|******************/
 
bool isLDT(const DateTime& curLST) {
    if(!USE_USLDT) return false;            // location uses US daylight savings
    int y = curLST.year() - 2000;           
    int x = (y + y/4 + 2) % 7;              // set boundary Sundays

    if(curLST.month() == 3 && 
       curLST.day() == (14 - x) && 
       curLST.hour() >= 2)
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 3 && 
       curLST.day() > (14 - x) || 
       curLST.month() > 3) 
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 11 && 
       curLST.day() == (7 - x) && 
       curLST.hour() >= 2) 
       return false;                        // time is Local Standard Time (LST)
   
    if(curLST.month() == 11 &&
       curLST.day() > (7 - x) || 
       curLST.month() > 11 || 
       curLST.month() < 3) 
       return false;                        // time is Local Standard Time (LST)
}
