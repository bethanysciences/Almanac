
/*
 * ---------------------------------------------------------------------------------------------
 * 
 * Almanac for specific Latitude and Longitudes
 * Operates independantly not needing an Internet connection
 * 
 * Bob Smith https://github.com/bethanysciences/almanac
 *  
 * Written and compiled under version 1.8.12+ of the Arduino IDE using the 
 * AVRISP mkII programmer for Arduino for Nano 33 IoT and Arduino Nano 33 
 * BLE based microprocessors
 * 
 * This program distributed WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  
 * Predictions generated by this program should NOT be used for navigation.
 * No accuracy or warranty is given or implied for these predictions.
 * 
 * 
 * 
 * * * * * * KEY FUNCTIONS USED * * * * 
 * ---------------------------------------------------------------------------------------------

 * 
 * * * * * * HARDWARE USED * * * * 
 * ---------------------------------------------------------------------------------------------
 * 
 * Microprocessors written for (others may work)
 * nRF52840
 * Arduino Nano 33 BLE Sense https://store.arduino.cc/usa/nano-33-ble-sense
 * Arduino Nano 33 BLE https://store.arduino.cc/usa/nano-33-ble
 * Interrupt Pins All
 * 
 * OLED Display
 * MakerHawk 1.5" 128x128 Pixels SSD1327 Driver I2C based OLED Display
 * https://www.amazon.com/s?k=MakerHawk&ref=bl_dp_s_web_18510440011 using Olikraus's 
 * https://github.com/olikraus/u8g2 library - installed from Arduino IDE as [oled_0]
 * setI2CAddress(0x7A) (0x78)
 * 
 * 
 *  * * * * * * MICE TYPE * * * * 
 * ---------------------------------------------------------------------------------------------
 * 
 * This application and project are open source using MIT License see license.txt
 * See included library github directories for their respecive licenses
 *  
 * ---------------------------------------------------------------------------------------------
 */

#define DEBUG false                                          // true setup and use serial print

#include <RTClib.h>                                         // version=1.8.0
RTC_Millis rtc;                                             // instantiate soft RTC

#include <Arduino_LPS22HB.h>
#include <Arduino_HTS221.h>
#include "Adafruit_VEML6075.h"
Adafruit_VEML6075 uv = Adafruit_VEML6075();

//---------- GLOBAL VARIABLES
int     FITZ                    = 13;                       // Fitzpatrick Score                0-32
int     SPF                     = 30;                       // SPF Applied                      0-100
bool    H2O                     = 0;                        // On Water                         bool
bool    SNOW                    = 0;                        // Snow Present                     bool 
double  UVINDEX;                                            // UV Index                         0.00-26.00
double  BARO_MB;                                            // Barometer (Pa)                   0-1086
double  ALT_M;                                              // Altitude (m)                     0-11000
int     MINS2MED;                                           // Mins to Minimal Erythemal Dose   0-inf
double  TEMP_C;                                             // Temperature degrees (Celsius)    0-50
double  TEMP_F;                                             // Temperature degrees (Fahrenheit) 0-120
double  BARO_PA;                                            // Barometer (pascals)              0-10860
double  BARO_HG;                                            // Barometer (inches mercury)           
double  HUMD;                                               // Relative humididty (%)           0-100
double  DEWPOINT;                                           // Dew Point (Fahrenheit)           0-100
double  HEATIX;                                             // Heat Index (Fahrenheit)          0-150
char    DATE[10];                                           // Date stamp
char    TIME[10];                                           // Time stamp
int     RECORDS;                                            // Number of records written


double med () {                                             // mins to Minimal Erythemal Dose (MED)
    double uvi_f =                                          // UV index factoring
                     (UVINDEX * (ALT_M * 1.2)) +            // alt factor (1.2 x meters above sea level)
                     (UVINDEX * (H2O * 1.5)) +              // on water UVindex factor (1.5x)
                     (UVINDEX * (SNOW * 1.85));             // on snow UVindex factor (1.85x)
    double s2med_b = (-3.209E-5 * pow(FITZ, 5)) +           // Fitzpatrick score @ 1 UV idx secs to MED
                     (2.959E-3 * pow(FITZ, 4)) -            // 5th order polynomial plot
                     (0.103 * pow(FITZ, 3)) +
                     (1.664* pow(FITZ, 2)) +
                     (3.82 * FITZ) + 
                     34.755;
    double s2med = ((s2med_b / uvi_f) * SPF);               // combine factors
    int m2med = s2med / 60;                                 // convert secs to mins
    if (m2med > 480) m2med = 480;                           // max at 6 hours
    return m2med;
}
double c2f(double celsius) {                            // convert Celcius to Fahrenheit
    return ((celsius * 9) / 5) + 32; 
}
double pa2hg(double pascals) {                          // convert Pascals to in. mercury
    return (pascals * 0.000295333727); 
}
double dewPointF(double cel, int hum) {                 // calc Dew Point
    double Td = (237.7 * ((17.271 * cel) / 
                (237.7 + cel) + 
                log(hum * 0.01))) / 
                (17.271 - ((17.271 * cel) / 
                (237.7 + cel) + 
                log(hum * 0.01)));
    return c2f(Td);
}
double heatIndex(double tempF, double humd_l) {         // calc Heat Index
    if (tempF < 80 || humd_l < 40) double pass = tempF; return pass;
    double c1=-42.38, c2=2.049;
    double c3=10.14, c4=-0.2248;
    double c5=-6.838e-3, c6=-5.482e-2;
    double c7=1.228e-3, c8=8.528e-4;
    double c9=-1.99e-6;
    double t = tempF;
    double r = humd_l;
    double a = ((c5 * t) + c2) * t + c1;
    double b = ((c7 * t) + c4) * t + c3;
    double c = ((c9 * t) + c8) * t + c6;
    double rv = (c * r + b) * r + a;
    return rv;
}
char *dtostrf (double val, signed char width, unsigned char prec, char *sout) {
  // convert floats to fixed string
  // val      Your float variable;
  // width    Length of the string that will be created INCLUDING decimal point;
  // prec     Number of digits after the deimal point to print;
  // sout     Destination of output buffer
    char fmt[20];
    sprintf(fmt, "%%%d.%df", width, prec);
    sprintf(sout, fmt, val);
    return sout;
}



#include <U8g2lib.h>
U8G2_SSD1327_MIDAS_128X128_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
#define LINE_HEIGHT             14
#define MARGIN_SIZE             3
#define COLUMN_2                70
#define TITLE_LINE              14
#define LOCATION_LINE           28
#define SENSOR_LINE             42
#define UVA_LINE                56
#define UVB_LINE                70
#define UVI_LINE                84
#define BAROMETER_LINE          98
#define TEMPERATURE_LINE        112
#define HUMIDITY_LINE           126




void setup() {
    asm(".global _printf_float");                           // printf renders floats

#if DEBUG
    Serial.begin(115200);
    while (!Serial);                                        // wait for serial port to open
    Serial.println("\nsetup() ------------------------------------------------------------");
#endif

    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));

    u8g2.setI2CAddress(0x7a);
    u8g2.begin();
    oledSetup();

    if (!uv.begin()) {
        Serial.println("Failed to initialize VEML6075");
        while (1);
    }
    delay(100);    

    uv.setIntegrationTime(VEML6075_100MS);
    uv.setHighDynamic(true);
    uv.setForcedMode(false);                                        // Set the mode
    uv.setCoefficients( 2.22, 1.33,                                 // UVA_A and UVA_B coefficients
                        2.95, 1.74,                                 // UVB_C and UVB_D coefficients
                        0.001461, 0.002591);                        // UVA and UVB responses

    if (!BARO.begin()) {
        Serial.println("Failed to initialize pressure sensor!");
        while (1);
    }

    if (!HTS.begin()) {
        Serial.println("Failed to initialize humidity temperature sensor!");
        while (1);
    }

    delay(1000);
}


void oledSetup() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_9x18_tr);
    
    char title[] = "WX Readings";
    u8g2.setCursor((u8g2.getDisplayWidth() - u8g2.getStrWidth(title))/2, TITLE_LINE);
    u8g2.print(title);
    
    u8g2.setFont(u8g2_font_crox1h_tf);
    char location[] = "Bethany Beach, DE USA";
    u8g2.setCursor((u8g2.getDisplayWidth() - u8g2.getStrWidth(location))/2, LOCATION_LINE);
    u8g2.print(location);

    u8g2.setFont(u8g2_font_9x18_tr);
    
    u8g2.setCursor(MARGIN_SIZE, UVA_LINE);            u8g2.print("UVA");
    u8g2.setCursor(MARGIN_SIZE, UVB_LINE);            u8g2.print("UVB");
    u8g2.setCursor(MARGIN_SIZE, UVI_LINE);            u8g2.print("UVIndx");
    u8g2.setCursor(MARGIN_SIZE, BAROMETER_LINE);      u8g2.print("Baro");
    u8g2.setCursor(MARGIN_SIZE, TEMPERATURE_LINE);    u8g2.print("Temp");
    u8g2.setCursor(MARGIN_SIZE, HUMIDITY_LINE);       u8g2.print("Humid");
    
    u8g2.sendBuffer();
}


void GetReadings() {                                        // readings by timer interval
    sprintf(TIME, "%02d%02d%02d",                           // time from real time clock
        rtc.getHours(),rtc.getMinutes(), rtc.getSeconds()); 
    UVINDEX     = uv.readUV();                              // VEML6070 UV reading
    UVINDEX     /= 100.0;                                   // convert to UV Index
    VOLTS       = (analogRead(VBAT_PIN) * 6.6)/1024;        // FEATHER battery voltage reading
    TEMP_C      = bme.readTemperature();                    // BME280 temperature (Celsius) reading
    TEMP_F      = c2f(TEMP_C);                              // convert Celsius reading to Fahrenheit
    BARO_PA     = bme.readPressure();                       // BME280 barometric pressure (Pascals) reading 
    BARO_MB     = BARO_PA / 100;                            // convert Pascals reading to millibars
    BARO_HG     = pa2hg(BARO_PA);                           // convert Pascals reading to Inches Mercury
    ALT_M       = bme.readAltitude(SEALEVELPRESSURE_HPA);   // BME280 calculated altitude reading
    if (ALT_M < 10.00) ALT_M = 0;                           // zero altitude if under 10 meters 
    HUMD        = bme.readHumidity();                       // BME280 relative humididty (%) reading
    DEWPOINT    = dewPointF(TEMP_C, HUMD);                  // calc Dew Point
    HEATIX      = heatIndex(TEMP_F, HUMD);                  // calc Heat Index
    MINS2MED    = med();                                    // calc mins to Minimal Erythemal Dose (MED)

#if DEBUG
    Serial.print("READINGS:");
    Serial.print(TIME);         Serial.print(" | ");
    Serial.print(VOLTS);        Serial.print(" | ");
    Serial.print(UVINDEX);      Serial.print(" | ");
    Serial.print(MINS2MED);     Serial.print(" | ");
    Serial.print(TEMP_C);       Serial.print(" | ");
    Serial.print(TEMP_F);       Serial.print(" | ");
    Serial.print(HUMD);         Serial.print(" | ");
    Serial.print(ALT_M);        Serial.print(" | ");
    Serial.print(BARO_PA);      Serial.print(" | ");
    Serial.print(BARO_MB);      Serial.print(" | ");
    Serial.print(BARO_HG);      Serial.print(" | ");
    Serial.print(DEWPOINT);     Serial.print(" | ");
    Serial.println(HEATIX);
#endif

}


void oledUpdate() {
    // ----------- UV INDEX
    char uvi_d[4]; 
    dtostrf(UVINDEX, 2, 1, uvi_d);
    char uvi[16];
    sprintf(uvi, "UV index %s", uvi_d);
    display.setCursor(0, LINE[2]);
    display.print(uvi);



    // ----------- DRAW UVI BAR
    display.fillRect(MARGIN,                            // clear bar
                    LINE[3],
                    display.width() - (MARGIN * 2),
                    CHAR_H,
                    WHITE);

    display.drawRect(MARGIN,                            // draw clear bar
                    LINE[3], 
                    display.width() - (MARGIN * 2),
                    CHAR_H,
                    BLACK);

    display.fillRect(MARGIN,                            // fill bar w/ last UV index reading
                    LINE[3],
                    (UVINDEX * ((display.width() -      // cover 16 divisions
                            (MARGIN * 2)) / 16)),
                    CHAR_H,
                    BLACK);


    // ---------- Mins to Minimal Erythemal Dose 
    char m2med[16];
    sprintf(m2med, "MED in %i min", MINS2MED);
    display.setCursor(0, LINE[4]); 
    display.print(m2med);


    // ---------- ALTITUDE
    char alt_d[4];
    dtostrf(ALT_M, 4, 0, alt_d);
 
    char alt[16];
    sprintf(alt, "Alt %s mtrs", alt_d);
    display.setCursor(0, LINE[5]); 
    display.print(alt);


    // ---------- TEMPC  TEMPF
    char temp_c_d[3]; 
    dtostrf(TEMP_C, 3, 0, temp_c_d);

    char temp_f_d[3]; 
    dtostrf(TEMP_F, 3, 0, temp_f_d);

    char temps[16];
    sprintf(temps, "Temps %sC %sF", temp_c_d, temp_f_d);
    display.setCursor(0, LINE[6]); 
    display.print(temps);


    // ---------- HUMD  BARO
    char humd_d[2]; 
    dtostrf(HUMD, 2, 0, humd_d);

    char baro_d[5];
    dtostrf(BARO_HG, 2, 2, baro_d);

    char humdbaro[16];
    sprintf(humdbaro, "%s%%rh %shg", humd_d, baro_d);
    display.setCursor(0, LINE[7]); 
    display.print(humdbaro);


    // ---------- DEWPOINT
    char dew_d[2]; 
    dtostrf(DEWPOINT, 2, 0, dew_d);

    char dew[16];
    sprintf(dew, "Dewpoint %sf", dew_d);
    display.setCursor(0, LINE[8]); 
    display.print(dew);


    // ---------- HEAT INDEX
    char heat_d[3]; 
    dtostrf(HEATIX, 3, 0, heat_d);

    char heat[16];
    sprintf(heat, "Heat Index %sf", heat_d);
    display.setCursor(0, LINE[9]);
    display.print(heat);
}


void loop() {
    u8g2.setFont(u8g2_font_9x18_tr);

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, UVA_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char uvaReading[] = "/0";    
    sprintf(uvaReading, "%d.%d", (int)uv.readUVA(), (int)(uv.readUVA()*10)%10);
    u8g2.setCursor(COLUMN_2, UVA_LINE);
    u8g2.print(uvaReading);
    u8g2.sendBuffer();

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, UVB_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char uvbReading[] = "/0";    
    sprintf(uvbReading, "%d.%d", (int)uv.readUVB(), (int)(uv.readUVB()*10)%10);
    u8g2.setCursor(COLUMN_2, UVB_LINE);
    u8g2.print(uvbReading);
    u8g2.sendBuffer();

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, UVI_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char uviReading[] = "/0";    
    sprintf(uviReading, "%d.%d", (int)uv.readUVI(), (int)(uv.readUVI()*100)%100);
    u8g2.setCursor(COLUMN_2, UVI_LINE);
    u8g2.print(uviReading);
    u8g2.sendBuffer();

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, BAROMETER_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char barometer[] = "/0";
    sprintf(barometer, "%d.%d", (int)BARO.readPressure(), (int)(BARO.readPressure()*10)%10);
    u8g2.setCursor(COLUMN_2, BAROMETER_LINE);
    u8g2.print(barometer);
    u8g2.sendBuffer();

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, TEMPERATURE_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char temperature[] = "/0";
    sprintf(temperature, "%d.%d°F", (int)HTS.readTemperature(FAHRENHEIT), 
                         (int)(HTS.readTemperature(FAHRENHEIT)*10)%10);
    u8g2.setCursor(COLUMN_2, TEMPERATURE_LINE);
    u8g2.print(temperature);
    u8g2.sendBuffer();

    u8g2.setDrawColor(0);
    u8g2.drawBox(COLUMN_2, HUMIDITY_LINE - LINE_HEIGHT, 127, LINE_HEIGHT);
    u8g2.setDrawColor(1);
    char humidity[] = "/0";
    sprintf(humidity, "%d%%", (int)HTS.readHumidity());
    u8g2.setCursor(COLUMN_2, HUMIDITY_LINE);
    u8g2.print(humidity);
    u8g2.sendBuffer();
       
    delay(3000);
}
