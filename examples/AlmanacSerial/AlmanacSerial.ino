/*
 * -----------------------------------------------------------------------------------------------
 * 
 * Almanac for specific Latitude and Longitudes
 * Operates independantly not needing an Internet connection
 * 
 * Bob Smith https://github.com/bethanysciences/almanac
 *  
 * Written and compiled under version 1.8.12+ of the Arduino IDE using the 
 * AVRISP mkII programmer for Arduino for Nano 33 IoT and Arduino Nano 33 
 * BLE based microprocessors
 * 
 * This program distributed WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTIBILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  
 * Predictions generated by this program should NOT be used for navigation.
 * No accuracy or warranty is given or implied for these predictions.
 * 
 * 
 * 
 * * * * * KEY FUNCTIONS USED * * * * 
 * -----------------------------------------------------------------------------------------------
 * Tide events calculated using Luke Miller's library of NOAA harmonic data 
 * https://github.com/millerlp/Tide_calculator derived from David Flater's
 * XTide application https://flaterco.com/xtide/xtide.html. Futher logic is
 * derived from rabbitcreek's https://github.com/rabbitcreek/tinytideclock
 * 
 * Sun events calculated using SunEvents library 
 * https://github.com/bethanysciences/SunEvents outputting sunrises and sets
 * to a RTClib DateTime object, a derivative of DM Kishi's library 
 * https://github.com/dmkishi/Dusk2Dawn, based on a port of NOAA's Solar 
 * Calculator https://www.esrl.noaa.gov/gmd/grad/solcalc/
 * 
 * 
 * * * * * * HARDWARE USED * * * * 
 * -----------------------------------------------------------------------------------------------
 * 
 * Microprocessors written for (others may work)
 * Arduino Nano 33 IoT https://store.arduino.cc/usa/nano-33-iot and 
 * Arduino Nano 33 BLE Sense https://store.arduino.cc/usa/nano-33-ble-sense
 * Arduino Nano 33 BLE https://store.arduino.cc/usa/nano-33-ble
 * 
 * 
 * Time Maintenance
 * Adafruit's battery backed I2C Maxim DS3231 Real Time Clock (RTC) Module 
 * https://www.adafruit.com/product/3013 using Adafruit's 
 * library https://github.com/adafruit/RTClib a fork of JeeLab's library 
 * https://git.jeelabs.org/jcw/rtclib - installed from Arduino IDE as [RTClib]
 * 
 * 
 * Lightening Events
 * Sparkfun's Franklin AS3935 Lightning Detector Breakout Board V2
 * https://www.sparkfun.com/products/15441 using Sparkfun's library 
 * https://github.com/sparkfun/SparkFun_AS3935_Lightning_Detector_Arduino_Library
 *  - installed from Arduino IDE as [SparkFun AS3935]
 * 
 * distanceToStorm()           strike distance in kilometers x .621371 for miles
 * clearStatistics()           zero distance registers
 * resetSettings()             resets to defaults
 * setNoiseLevel(int)          read/set noise floor 1-7 (2 default)
 * readNoiseLevel()
 * maskDisturber(bool)         read/set mask disturber events (false default)
 * readMaskDisturber(bool)
 * setIndoorOutdoor(hex)       0xE, 0x12 (default) attunates for inside use
 * readIndoorOutdoor(hex)
 * watchdogThreshold(int)      read/set watchdog threshold 1-10 (2 default)
 * readWatchdogThreshold()
 * spikeRejection(int)         read/set spike reject 1-11 (2 default)
 * readSpikeRejection()
 * lightningThreshold(int)     read/set # strikes to trip interrupt 1,5,9, or 26
 * readLightningThreshold()
 * lightningEnergy(long)       strike energy
 * lightning.powerDown()       wake after power down resets internal resonators
 * lightning.wakeUp()          to default antenna resonance frequency (500kHz)
 *                             skewing built-up calibrations. Calibrate 
 *                             antenna before using this function
 * 
 *  *  * * * * * * MICE TYPE * * * * 
 * ---------------------------------------------------------------------------------------------
 * 
 * This application and project are open source using MIT License see 
 * license.txt.
 *  
 * See included library github directories for their respecive licenses
 *  
 *  
 *  
 *  
 *  
 *  
 * -----------------------------------------------------------------------------------------------
 */

// ------------  DS3231 REAL-TIME CLOCK  ---------- //
#include <RTClib.h>                                 // version=1.8.0
RTC_DS3231 rtc;                                     // instantiate RTC module
#define USE_USLDT           true                    // location uses US daylight savings
char LOC[3][4]              = {"LST","LDT"};        // Local Standard Time (LST)
                                                    // Local Daylight Time (LDT)
#define GMT_OFFSET          -5                      // LST hours GMT offset

// ------------  SUN EVENTS  ---------------------- //
#include <SunEvent.h>                               // version=0.1.0
float LATITUDE                  = 38.5393;      // Bethat Beach, DE, USA
float LONGITUDE                 = -75.0547;
SunEvent BethanyBeach(LATITUDE, LONGITUDE, GMT_OFFSET);

// ------------  TIDE CALCULATIONS  --------------- //
#include "TidelibDelawareCityDelawareRiverDelaware.h"
TideCalc myTideCalc;

/*
// ------------  AS3935 LIGHTNING  ---------------- //
#include <SparkFun_AS3935.h>
#define LIGHTNING_INT           0x08
#define DISTURBER_INT           0x04
#define NOISE_INT               0x01
#define AS3935_CS               10                   // AS3935 chip select pin
#define AS3935_STRIKE           2                   // strike detection interrupt pin (HIGH)
#define AS3935_MASK_DISTURB     true
byte noiseFloor = 2;                                // default
byte watchDogVal = 2;                               // default
byte spike = 2;                                     // default
byte lightningThresh = 1;                           // default
SparkFun_AS3935 strike;
*/

void setup() {
    asm(".global _printf_float");                               // printf renders floats

    Serial.begin(115200);
    while (!Serial);                                            // wait for serial port to open
    Serial.println("\n\nstartup\n\n");

    if (! rtc.begin()) while (1);                               // wait until RTC starts
    if (rtc.lostPower()) {                                      // on power loss reset time
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }

/*
    pinMode(AS3935_STRIKE, INPUT);                              // strike detected int pin set
    while(!strike.beginSPI(AS3935_CS, 2000000));
    strike.maskDisturber(true);

    delay(5000);                                                // flush registers
*/

    statusScreen();
}

void loop() {
/*    if(digitalRead(AS3935_STRIKE) == HIGH) {                    // check for lightening event
        eventDetected();
    }
*/

    getTideEvents();                                         // run tide and sun events
    getSunEvents();
}

void displayTime() {
    DateTime now = rtc.now();                                   // get current time from RTC

    char curr_date_buf[] = "DDD  MM/DD/YY ";
    Serial.print(now.toString(curr_date_buf));

    char curr_time_buf[] = "hh:mm:ss AP ";
    Serial.print(now.toString(curr_time_buf));

    Serial.print(LOC[isLDT(now)]);                              // render LST or LDT
}

/*
void eventDetected() {

    int intVal = strike.readInterruptReg();
    
    if(intVal == NOISE_INT) {
        Serial.print("event detected with register 0x0");
        Serial.print(intVal, HEX);
        Serial.println("\tnoise event");
    }
    else if(intVal == DISTURBER_INT) {
        Serial.print("event detected with register 0x0");
        Serial.print(intVal, HEX);        
        Serial.println("\tdisturber event");
    }
    else if(intVal == LIGHTNING_INT) {
        Serial.print("event detected with register 0x0");
        Serial.print(intVal, HEX);        
        Serial.print("\tstrike distance ");
        Serial.print(strike.distanceToStorm() /.621371);         //  * .621371 for miles
        Serial.println(" mi.");
    }
}
*/

void getTideEvents() {
    float INTERVAL              = 1 * 5 * 60L;      // tide calc interval
    float results;                                  // needed to print tide height
    DateTime futureHigh;
    DateTime futureLow;
    DateTime future;
    uint8_t slope;
    uint8_t i                   = 0;
    uint8_t zag                 = 0;
    bool    gate                = 1;
    float   tidalDifference     = 0;
    bool    bing                = 1;
    bool    futureLowGate       = 0;
    bool    futureHighGate      = 0;

    DateTime now = rtc.now();                       // current time from RTC
    DateTime adjnow(now.unixtime() 
             - (isLDT(now) * 3600));                // convert to LST during LDT

    float pastResult = myTideCalc.currentTide(adjnow);

    while(bing){
        i++;
        DateTime future(adjnow.unixtime() + (i * INTERVAL));
        results = myTideCalc.currentTide(future);
        tidalDifference = results - pastResult;
        if (gate){
            if(tidalDifference < 0) slope = 0;
            else slope = 1;
            gate = 0;
        }
        if(tidalDifference > 0 && slope == 0) {
            futureLow = future;
            gate = 1;
            //bing = 0;
            futureLowGate = 1;
        }
        else if(tidalDifference < 0 && slope == 1){
            futureHigh = future;
            gate = 1;
            //bing = 0;
            futureHighGate = 1;
        }
        if(futureHighGate && futureLowGate) {
            bool hiLow;
            float resultsHigh = myTideCalc.currentTide(futureHigh);
            float resultsLow  = myTideCalc.currentTide(futureLow);

            if(int(futureHigh.unixtime() - futureLow.unixtime()) < 0) hiLow = 1;
            if(int(futureHigh.unixtime() - futureLow.unixtime()) > 0) hiLow = 0;

            if (hiLow) {
                DateTime adjHigh(futureHigh.unixtime() + 
                (isLDT(futureHigh) * 3600));

                char high_buf[] = "Next High tide MM/DD/YY hh:mm ap ";
                Serial.print(adjHigh.toString(high_buf));
                Serial.print(LOC[isLDT(adjHigh)]);            // render LST or LDT
                Serial.print(" level ");
                Serial.print(resultsHigh, 2);
                Serial.println(" feet");

                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));

                char low_buf[] = "Next Low tide  MM/DD/YY hh:mm ap ";
                Serial.print(adjLow.toString(low_buf));
                Serial.print(LOC[isLDT(adjLow)]);            // render LST or LDT
                Serial.print(" level ");
                Serial.print(resultsLow, 2);
                Serial.println(" feet");

            }
            else {
                DateTime adjLow(futureLow.unixtime() + 
                         (isLDT(futureLow) * 3600));

                char low_buf[] = "Next Low tide  MM/DD/YY hh:mm ap ";
                Serial.print(adjLow.toString(low_buf));
                Serial.print(LOC[isLDT(adjLow)]);            // render LST or LDT
                Serial.print(" level ");
                Serial.print(resultsLow, 2);
                Serial.println(" feet");

                DateTime adjHigh(futureHigh.unixtime() + 
                         (isLDT(futureHigh) * 3600));

                char high_buf[] = "Next High tide MM/DD/YY hh:mm ap ";
                Serial.print(adjHigh.toString(high_buf));
                Serial.print(LOC[isLDT(adjHigh)]);            // render LST or LDT
                Serial.print(" level ");
                Serial.print(resultsHigh, 2);
                Serial.println(" feet");

            }
            results = myTideCalc.currentTide(adjnow);
            gate = 1;
            bing = 0;
            futureHighGate = 0;
            futureLowGate  = 0;
        }
        pastResult = results;
    }
}

void getSunEvents() {
    DateTime nextrise = BethanyBeach.sunrise(rtc.now());
    char rise_buf[] = "Next Sunrise hh:mm ap ";
    Serial.print(nextrise.toString(rise_buf));
    Serial.println(LOC[isLDT(nextrise)]);               // render LST or LDT

    DateTime nextset  = BethanyBeach.sunset(rtc.now());
    char set_buf[] = "Next Sunset hh:mm ap ";
    Serial.print(nextset.toString(set_buf));
    Serial.println(LOC[isLDT(nextset)]);                // render LST or LDT

    TimeSpan sunlight = nextset.unixtime() - nextrise.unixtime();
    char light_buf[20];
    sprintf(light_buf, "%d hours %d minutes of daylight today", 
            sunlight.hours(), sunlight.minutes());
    Serial.println(light_buf);
}

bool isLDT(const DateTime& curLST) {
    if(!USE_USLDT) return false;            // location uses US daylight savings
    int y = curLST.year() - 2000;
    int x = (y + y/4 + 2) % 7;              // set boundary Sundays

    if(curLST.month() == 3 &&
       curLST.day() == (14 - x) &&
       curLST.hour() >= 2)
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 3 && 
       curLST.day() > (14 - x) || 
       curLST.month() > 3) 
       return true;                         // time is Local Daylight Time (LDT)

    if(curLST.month() == 11 && 
       curLST.day() == (7 - x) && 
       curLST.hour() >= 2) 
       return false;                        // time is Local Standard Time (LST)

    if(curLST.month() == 11 &&
       curLST.day() > (7 - x) || 
       curLST.month() > 11 || 
       curLST.month() < 3) 
       return false;                        // time is Local Standard Time (LST)
}


void statusScreen() {
    Serial.println("statusScreen()\n");

    Serial.println("-----------------------------------------------------------------------\n");

    char tF[2][10]   = {"FALSE", "TRUE"};

    // --- Get and Display DS3231SN RTC Paramters ---
    Serial.println("DS3231SN Paramters");

    DateTime now = rtc.now();                                   // get current time from RTC

    Serial.print("lostPower()\t\t");
    Serial.println(tF[rtc.lostPower()]);
    Serial.print("readSqwPinMode()\t");
    Serial.println(rtc.readSqwPinMode());
    Serial.print("isEnabled32K()\t\t");
    Serial.println(tF[rtc.isEnabled32K()]);
    Serial.print("chip temperature\t");
    Serial.print(rtc.getTemperature());
    Serial.println("°C");

    Serial.print("current time\t\t");
    char curr_date_buf[] = "DDD  MM/DD/YY ";
    Serial.print(now.toString(curr_date_buf));

    char curr_time_buf[] = "hh:mm:ss AP ";
    Serial.print(now.toString(curr_time_buf));

    Serial.println(LOC[isLDT(now)]);                            // render LST or LDT

    Serial.println("elapsed since midnight 1/1/1970");
    Serial.print("\tseconds\t");
    Serial.println(now.unixtime());
    Serial.print("\tdays\t");
    Serial.println(now.unixtime() / 86400L);

    Serial.println("-----------------------------------------------------------------------\n");

/*
    // --- Get and Display AS3935 Paramters ---
    char disturberMask[2][20]   = {"ON", "OFF"};
    char inOutdoor[2][20]       = {"INSIDE", "OUTSIDE"};
    int inOut;
    if (strike.readIndoorOutdoor() == 18) inOut = 0;
    else inOut = 1;

    Serial.println("AS3935 Paramters");
    Serial.print("MaskDisturber()\t\t");
    Serial.println(disturberMask[strike.readMaskDisturber()]);
    Serial.print("IndoorOutdoor()\t\t");
    Serial.println(inOutdoor[inOut]);
    Serial.print("NoiseLevel()\t\t");
    Serial.println(strike.readNoiseLevel());
    Serial.print("WatchdogThreshold()\t");
    Serial.println(strike.readWatchdogThreshold());
    Serial.print("SpikeRejection()\t");
    Serial.println(strike.readSpikeRejection());
    Serial.print("LightningThreshold()\t");
    Serial.println(strike.readLightningThreshold());

    Serial.println("Wiggle LED_BUILTIN");
    for(int x = 0; x < 5; x++){
        digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
        delay(500);
    }
*/

}

void batterySprite() {
    Serial.print("batterySprite\t");
    #define VBATPIN         A6
    float batteryVolts = analogRead(VBATPIN);
    batteryVolts *= 2;
    batteryVolts *= 3.3;
    batteryVolts /= 1024;
    char buf0[15];
    sprintf(buf0, "batt %d.%02dv", (int)batteryVolts, (int)(batteryVolts*100)%100);
    Serial.println(buf0);
}
